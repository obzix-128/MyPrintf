section .text

global myPrintf

myPrintf:
    pop rax  ; Взял адрес возврата

    mov [rel SAVE_TRUMP + 8 * 0], rbx ; Регистр rbx должен сохранять своё значение
    mov [rel SAVE_TRUMP + 8 * 1], rbp ; Регистр rbp должен сохранять своё значение
    mov [rel SAVE_TRUMP + 8 * 2], r12 ; Регистр r12 должен сохранять своё значение
    mov [rel SAVE_TRUMP + 8 * 3], r15 ; Регистр r15 должен сохранять своё значение

    push r9  ; Шестой аргумент передаётся в r9
    push r8  ; Пятый аргумент передаётся в r8
    push rcx ; Четвёртый аргумент передаётся в rcx
    push rdx ; Третий аргумент передаётся в rdx
    push rsi ; Второй аргумент передаётся в rsi
    push rdi ; Первый аргумент передается в rdi 

    push rax ; Положил адрес возврата на вершину стэка

    jmp myPrintfOrig

MyPrintfEnd:
    pop r8         ; Взял адрес возврата
    add rsp, 6 * 8 ; Очистил стэк
    push r8        ; Положил на место адрес возврата

    mov rbx, [rel SAVE_TRUMP + 8 * 0] ; Восстановил значение rbx
    mov rbp, [rel SAVE_TRUMP + 8 * 1] ; Восстановил значение rbp
    mov r12, [rel SAVE_TRUMP + 8 * 2] ; Восстановил значение r12
    mov r15, [rel SAVE_TRUMP + 8 * 3] ; Восстановил значение r15

    ret

;---------------------------------------------------------------------------------------------------------
; Функция аналог printf
; Entry: 
; Exit : 
; Destr: 
;---------------------------------------------------------------------------------------------------------

myPrintfOrig:
    cld                               ; Занулил флаг направления

    mov [rel SAVE_CDECL + 8 * 0], rbx ; Регистр rbx должен сохранять своё значение
    mov [rel SAVE_CDECL + 8 * 1], rbp ; Регистр rbp должен сохранять своё значение
    mov [rel SAVE_CDECL + 8 * 2], rsi ; Регистр rsi должен сохранять своё значение
    mov [rel SAVE_CDECL + 8 * 3], rdi ; Регистр rdi должен сохранять своё значение

    pop rbx
    mov qword [rel RETURN_ADDRESS], rbx ; Вытащил из стека и сохранил адрес возврата

    mov r8, rsp ; В r8 кладём адрес аргументов в стэке, чтоб потом обращаться напрямую к ним 

    mov rbx, qword [rsp]         ; Кладём адрес строки (первый аргумент) в rbx
    add r8, 8                    ; Передвигаем указатель на второй аргумент
    lea rsi, [rel PRINTF_BUFFER] ; Положил в rsi адрес буфера

    .buffer_loop:
        call fillBuffer   ; Вызываем функцию для заполнения буфера, который мы будем распечатывать
        mov rax, 1        ; Номер системного вызова write (1)
        mov rdi, 1        ; Файловый дескриптор (1 = stdout)
        syscall           ; Вызов системного вызова
        cmp byte [rbx], 0 ; Сравниваем текущий символ с нулем
        jne .buffer_loop  ; Если не нулевой байт, повторяем

    mov rcx, qword [rel RETURN_ADDRESS]
    push rcx                            ; Вернул в стэк адрес возврата

    mov rbx, [rel SAVE_CDECL + 8 * 0] ; Восстановил значение rbx
    mov rbp, [rel SAVE_CDECL + 8 * 1] ; Восстановил значение rbp
    mov rsi, [rel SAVE_CDECL + 8 * 2] ; Восстановил значение rsi
    mov rdi, [rel SAVE_CDECL + 8 * 3] ; Восстановил значение rdi

    jmp MyPrintfEnd ; Возврат из функции

;---------------------------------------------------------------------------------------------------------
; Заполняет буфер принтфа
; Entry: rbx - адрес строки
;        rsi - адрес буфера для записи
;        r8  - адрес аргументов в стэке
; Exit : rdx - длина строки для распечатки, для системного вызова
; Destr: rax, rcx
;---------------------------------------------------------------------------------------------------------

fillBuffer:
    push rsi
    mov rcx, BUFFER_SIZE     ; Задал длину счётчика для заполнения буфера

    .buffer_loop:
        cmp byte [rbx], 0 ; Сравниваем текущий символ с нулем
        je .filling_done  ; Если нулевой байт, завершаем

        cmp byte [rbx], '%' ; Проверка на ключевой символ
        jne .usual_symbol   ; Если не ключевой символ прыгаем на стандартную обработку

        inc rbx             ; Переходим на ключевой символ (стоящий после %)
        call keywordHandler ; Если ключевой, вызываем обработчик
        cmp rcx, 0          ; Проверяем осталось ли место в буфере
        je .filling_done    ; Если нет, выходим из цикла
        jmp .buffer_loop    ; Если осталось, начинаем цикл заново

        .usual_symbol:
            mov dl, [rbx]    
            mov [rsi], dl     ; В два mov-a переложили байт из аргумента в буфер
            inc rbx           ; Переходим на следующий символ
            inc rsi           ; Переходим на следующий символ
            loop .buffer_loop ; Повторяем, пока буфер не заполнится

    .filling_done:
        mov rdx, BUFFER_SIZE ; Положили в rdx длину буфера
        sub rdx, rcx         ; Вычислили, сколько нужно распечатать символов

    pop rsi
    ret ; Возврат из функции


;---------------------------------------------------------------------------------------------------------
; Обрабатывает ключевой (стоящий после %) символ строки.
; Entry: rbx - адрес ключевого символа
;        rsi - адрес буфера для записи
;        rcx - количество свободных байт в буфере
;        r8  - адрес аргументов в стэке
; Exit : rcx - количество свободных байт в буфере после обработки
; Destr: rdx, rdi, rax
;---------------------------------------------------------------------------------------------------------

keywordHandler:
    cmp byte [rbx], '%' ; Отдельно проверяем %, так как он невыгодно добавлять его в джамп таблицу
    je percent_case     ; Если %, прыгаем на вариант обработки %

    xor rdx, rdx
    mov dl, byte [rbx] ; Кладём в rdx значение для прыжка по джамп таблице
    inc rbx            ; Пропускаем ключевой символ

    sub rdx, 'b' ; Подготавливаем значение для джамп таблицы

    cmp rdx, 'x' - 'b' ; 'x' - ключевой символ с самым большим ASCII-кодом, если следующий за
    ja default_case    ; '%' символ имеет больший ASCII-код, то обрабатываем через default

    lea rdi, [rel JUMP_TABLE] ; Загружаем адрес джамп-таблицы 
    jmp [rdi + rdx * 8]       ; Переходим по адресу из таблицы

    ret

default_case:     ; ИЗМЕНИТЬ!
    mov dl, [rbx]    
    mov [rsi], dl ; В два mov-a переложили байт из аргумента в буфер
    inc rsi       ; Переходим на следующий символ
    dec rcx       ; Меняем значение счётчика
    ret           ; Возвращаемся

percent_case:
    mov dl, [rbx]    
    mov [rsi], dl ; В два mov-a переложили байт из аргумента в буфер
    inc rsi       ; Переходим на следующий символ
    dec rcx       ; Меняем значение счётчика
    ret           ; Возвращаемся

case_c:
    mov dl, [r8]
    mov [rsi], dl ; В два mov-a переложили байт из аргумента в буфер
    inc rsi       ; Переходим на следующий символ в буфере
    add r8, 8     ; Переходим на следующий аргумент
    dec rcx       ; Меняем значение счётчика
    ret           ; Возвращаемся

case_s:
    mov rdi, [r8]
    add r8, 8     ; Переходим на следующий аргумент

    call my_strlen ; Вычисляем длину строки для распечатки

    cmp rax, BUFFER_SIZE
    ja .print            ; Если строка длиннее нашего буфера, то печатаем её самостоятельно
    cmp rcx, rax
    jae .paste_in_buffer ; Если места в буфере достаточно, записываем строку туда

    push rax
    push rdi
    call freeBuffer ; Если места в буфере не хватало для строки, то мы его чистим
    pop rdi
    pop rax

    .paste_in_buffer:        ; Записываем строку в буфер
        mov dl, [rdi]        ; Загружаем текущий символ строки в dl
        inc rdi              ; Двигаемся дальше по строке
        test dl, dl          ; Проверяем, равен ли символ нулю
        jz .paste_done       ; Если символ нулевой, завершаем цикл
        mov [rsi], dl        ; Записываем символ в буфер
        inc rsi              ; Переходим на следующий символ в буфере
        dec rcx              ; Меняем значение счётчика
        jmp .paste_in_buffer

    .paste_done:
        ret                  ; После вставки строки в буфер возвращаемся

    .print:             ; Печатаем строку отдельным вызовом:
        push rax
        push rdi 
        call freeBuffer ; Сначала печатаем всё, что было до строки
        pop rdi
        pop rax

        push rsi
        push rcx
        mov rsi, rdi ; Переместили адрес строки в rsi
        mov rdx, rax ; В rdx положили, сколько нужно распечатать символов
        mov rax, 1   ; Номер системного вызова write (1)
        mov rdi, 1   ; Файловый дескриптор (1 = stdout)
        syscall      ; Вызов системного вызова  
        pop rcx   
        pop rsi   

        ret

case_d:
    cmp rcx, MAX_BIN_NUMBER_SIZE ; Проверил хватит ли места
    jg .print_dec_number         ; Если да, начал писать
    call freeBuffer              ; Если нет, освободил буфер

    .print_dec_number:
        lea rdi, [rel HEX_DIGITS]   ; В rdi положил адрес строчки с шестнадцатиричными символами
        mov rdx, qword [r8]         ; В rdx положил число, которое будем преобразовывать
        add r8, 8                   ; Переходим на следующий аргумент
        xor r9, r9                  ; Задаём счётчик

    cmp rdx, 0          ; Проверил, не равен ли нулю аргумент
    jne .first_bit      ; Если да,то:
    mov al, [rdi + rdx] ; В al записали 0
    mov [rsi], al       ; Записали цифру в буфер
    inc rsi             ; Переходим на следующий символ в буфере
    dec rcx             ; Меняем значение счётчика
    ret

    .first_bit:
        mov rax, rdx
        and eax, 0x80000000
        cmp eax, 0
        je .print_digits
        mov al, '-'   ; В al записали '-'
        mov [rsi], al ; Записали '-' в буфер
        inc rsi       ; Переходим на следующий символ в буфере
        dec rcx       ; Меняем значение счётчика буфера
        neg edx       ; В edx теперь положительное число. Обработаем его

    .print_digits:
        mov rax, rdx ; Переместил значение аргумента в rax, для последующего преобразования
        lea r10, [rel CONVERT_BUFFER]

        .print_one_digit:
            xor rdx, rdx         ; Почистил rdx перед делением 
            mov r11, 10
            div r11              ; Поделил значение на основание системы счисления
            mov dl, [rdi + rdx]  ; В dl положил нужнцю цифру
            mov [r10], dl        ; Положил цифру во временный буфер
            inc r10              ; Сдвинул указатель на временный буфер
            inc r9               ; Увеличил на 1 счётчик записанных символов
            cmp rax, 0           ; Сравнил аргумент с 0
            jne .print_one_digit ; Если равен, значит все цифры обработаны

        .move_one_digit:
            mov al, [r10]
            mov [rsi], al ; Переместил цифру из временного буфера в буфер принтфа
            inc rsi       ; Сдвинул указатель на буфер принтфа
            dec rcx       ; Уменьшил счётчик свободного места в буфера
            dec r10       ; Сдвинул указатель на временный буфер
            dec r9        ; Уменьшил счётчик записанных во временный буфер символов
            cmp r9, -1    ; Пока временный буфер не пуст, продолжаем
            jne .move_one_digit

    ret

case_b:
    cmp rcx, MAX_BIN_NUMBER_SIZE ; Проверил хватит ли места
    jg .print_bin_number         ; Если да, начал писать
    call freeBuffer              ; Если нет, освободил буфер

    .print_bin_number:
        mov r11, 1        ; Положил в r11 число битов, задающее одну цифру
        call print_number

    ret

case_o:
    cmp rcx, MAX_OCT_NUMBER_SIZE ; Проверил хватит ли места
    jg .print_oct_number         ; Если да, начал писать
    call freeBuffer              ; Если нет, освободил буфер

    .print_oct_number:
        mov r11, 3        ; Положил в r11 число битов, задающее одну цифру
        call print_number

    ret

case_x:
    cmp rcx, MAX_HEX_NUMBER_SIZE ; Проверил хватит ли места
    jg .print_hex_number         ; Если да, начал писать
    call freeBuffer              ; Если нет, освободил буфер

    .print_hex_number:
        mov r11, 4        ; Положил в r11 число битов, задающее одну цифру
        call print_number

    ret

;---------------------------------------------------------------------------------------------------------
; Получает аргумент, который записывает в буфер в виде 2,8,16-ричного числа
; Entry: r11  - Количество бит в одной цифре (например, 4 - для 16-ричной)
;        rsi  - буфер для записи
;        rcx  - кол-во свободных байт в буфере
;        [r8] - аргумент
; Exit : None
; Destr: 
;---------------------------------------------------------------------------------------------------------

print_number:
    lea rdi, [rel HEX_DIGITS] ; В rdi положил адрес строчки с шестнадцатиричными символами
    mov rdx, qword [r8]       ; В rdx положил число, которое будем преобразовывать
    add r8, 8                 ; Переходим на следующий аргумент

    cmp rdx, 0          ; Проверил, не равен ли нулю аргумент
    jne .print_digits   ; Если да,то:
    mov al, [rdi + rdx] ; В al записали 0
    mov [rsi], al       ; Записали цифру в буфер
    inc rsi             ; Переходим на следующий символ в буфере
    dec rcx             ; Меняем значение счётчика
    ret

    .print_digits:
        lea r10, [rel CONVERT_BUFFER] ; в r10 положили адрес временного буфера
        xor r9, r9                    ; Задали счётчик заполнения временного буфера
        push rcx                      ; Сохранил значение rcx, будем использовать cl для побитовых сдвигов 
        mov rcx, r11                  ; В cl положил кол-во бит, задающих одну цифру

        .print_one_digit:
            mov rax, rdx         ; Переместил значение аргумента в rax
            mov r11, 1
            shl r11, cl 
            sub r11, 1           ; В r11 создали маску из cl единичек в бладших битах
            and rax, r11         ; Сохранил в rax только cl битов
            shr rdx, cl          ; Сдвинулся в rdx на следующую цифру, для следующего цикла 
            mov al, [rdi + rax]  ; В dl положил нужную цифру
            mov [r10], al        ; Положил цифру во временный буфер
            inc r10              ; Сдвинул указатель на временный буфер
            inc r9               ; Увеличил на 1 счётчик записанных символов
            cmp rdx, 0           ; Сравнил аргумент с 0
            jne .print_one_digit ; Если равен, значит все цифры обработаны

        pop rcx ; Восстановил значение rcx

        .move_one_digit:
            mov al, [r10]
            mov [rsi], al ; Переместил цифру из временного буфера в буфер принтфа
            inc rsi       ; Сдвинул указатель на буфер принтфа
            dec rcx       ; Уменьшил счётчик свободного места в буфера
            dec r10       ; Сдвинул указатель на временный буфер
            dec r9        ; Уменьшил счётчик записанных во временный буфер символов
            cmp r9, -1    ; Пока временный буфер не пуст, продолжаем
            jne .move_one_digit
    
    ret

;---------------------------------------------------------------------------------------------------------
; Измеряет длину строки, пока не встретит нулевой символ
; Entry: rdi - адрес строки
; Exit : rax - длина строки
; Destr: rdx
;---------------------------------------------------------------------------------------------------------

my_strlen:
    xor rax, rax ; Обнуляем rax (счётчик длины строки)

    .strlen_loop:
        mov dl, [rdi + rax]   ; Загружаем текущий символ строки в dl
        test dl, dl           ; Проверяем, равен ли символ нулю
        jz .strlen_done       ; Если символ нулевой, завершаем цикл
        inc rax               ; Увеличиваем счётчик длины
        jmp .strlen_loop      ; Переходим к следующему символу

    .strlen_done:
        ret ; Возвращаем длину строки в rax

;---------------------------------------------------------------------------------------------------------
; Печатает всё, что есть в буфере в данный момент
; Entry: rsi - адрес буфера
; Exit : None
; Destr: rdx, rax, rdi
;---------------------------------------------------------------------------------------------------------

freeBuffer:
    push rcx
    mov rdx, BUFFER_SIZE ; Положили в rdx длину буфера
    sub rdx, rcx         ; Вычислили, сколько нужно распечатать символов
    mov rax, 1           ; Номер системного вызова write (1)
    mov rdi, 1           ; Файловый дескриптор (1 = stdout)
    syscall              ; Вызов системного вызова
    pop rcx
    ret

;=========================================================================================================
section .rodata

BUFFER_SIZE equ 100 ; Длина буфера моего принтфа |Не ставить меньше 64| !!!
MAX_HEX_NUMBER_SIZE equ 16 ; Максимальная возможная длина шестнадцатиричного числа при распечатке
MAX_DEC_NUMBER_SIZE equ 20 ; Максимальная возможная длина десятичного числа при распечатке
MAX_OCT_NUMBER_SIZE equ 22 ; Максимальная возможная длина восьмеричного числа при распечатке
MAX_BIN_NUMBER_SIZE equ 64 ; Максимальная возможная длина двоичного числа при распечатке

HEX_DIGITS db "0123456789ABCDEF"

;=========================================================================================================
section .data

CONVERT_BUFFER times MAX_BIN_NUMBER_SIZE db 0 ; Буфер для конвертации чисел

PRINTF_BUFFER times BUFFER_SIZE db 0 ; Буфер моего принтфа

RETURN_ADDRESS dq 0

SAVE_TRUMP times 4 dq 0 ; Буфер, чтоб в трамплине сохранить значения четырёх регистров
SAVE_CDECL times 4 dq 0 ; Буфер, чтоб сохранить значения четырёх регистров согласно cdecl

JUMP_TABLE:
    dq case_b                  ; b
    dq case_c                  ; c
    dq case_d                  ; d
    times (10) dq default_case ; Заполняем пропуски от d до o
    dq case_o                  ; o
    times (3) dq default_case  ; Заполняем пропуски от o до s
    dq case_s                  ; s
    times (4) dq default_case  ; Заполняем пропуски от s до x
    dq case_x                  ; x